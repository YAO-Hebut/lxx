#栈
![avatar](https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/4a36acaf2edda3cc20899e7608e93901213f9272.jpg)
####1.利用栈的思想来解决“括号匹配”问题
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
typedef char ElementType;
typedef struct Node *PtrToNode;
struct Node
{
    ElementType Data;
    PtrToNode Next;
};
typedef PtrToNode List;

List Create();
bool isEmpty(List L); //栈是否为空
bool Push(List L, ElementType x);
ElementType Pop(List L);
bool isTrue(char s[]); //括号匹配
int main()
{
    char s[101];
    gets(s);
    if (isTrue(s))
    {
        printf("yes\n");
    }
    else
    {
        printf("no\n");
    }
}
List Create()
{
    List L = (List)malloc(sizeof(struct Node));
    L->Next = NULL;//创建一个空栈，设置的该类栈顶为空
    return L;
}

bool isEmpty(List L)
{
    return (L->Next == NULL);
}

bool Push(List L, ElementType x)
{
    bool flag = false;
    List p = (List)malloc(sizeof(struct Node));//给p动态分配空间
    p->Data = x;//入栈数赋给p->Data
    p->Next = L->Next;//通过节点p进入入栈L
    L->Next = p;//L的指针next上升一层(到达栈顶)
    flag = true;
    return flag;
}

ElementType Pop(List L)
{
    if (isEmpty(L))
    {
        return '-1';
    }
    else
    {
        ElementType flag = L->Next->Data;//返回的是栈顶的下一个的data值(栈顶为空)
        List p;
        p = L->Next;//p现在所指向的节点是将要被pop操作弹出栈的节点
        L->Next = p->Next;//该栈直接指向被弹出的节点的下一个节点
        free(p);//释放掉被弹出的节点
        return flag;//返回栈顶data值
    }
}
bool isTrue(char s[])
{
    int i = 0;
    char x;
    bool flag = true;
    List L = Create();
    while (s[i] != '\0')
    {
        if (s[i] == '(' || s[i] == '[' || s[i] == '{')
        {
            Push(L, s[i]); //左括号入栈
        }
        if (s[i] == ')')
        {
            x = Pop(L);
            if (x != '(')//若不匹配直接返回false并跳出
            {
                flag = false;
                break;
            }
        }
        if (s[i] == ']')
        {
            x = Pop(L);
            if (x != '[')//若不匹配直接返回false并跳出
            {
                flag = false;
                break;
            }
        }
        if (s[i] == '}')
        {
            x = Pop(L);
            if (x != '{')//若不匹配直接返回false并跳出
            {
                flag = false;
                break;
            }
        }
        i++;
    }
    if (!isEmpty(L))
        flag = false;//若还有剩余的“单独”括号，也说明匹配失败
    return flag;
}
```